<!DOCTYPE html><!--lLKmyGbgC9GZXyGPxKThQ--><html lang="en"><head><meta charSet="UTF-8"/><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" as="image" href="https://imgs.xkcd.com/comics/lisp_cycles.png"/><link rel="stylesheet" href="/_next/static/css/0f63a619df29c78b.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/5eacd01f773eed7f.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-6b8b512d4121474e.js"/><script src="/_next/static/chunks/4bd1b696-c023c6e3521b1417.js" async=""></script><script src="/_next/static/chunks/255-a7ba4d37dca2f1fa.js" async=""></script><script src="/_next/static/chunks/main-app-bdb7cdcf0fbe007a.js" async=""></script><script src="/_next/static/chunks/619-ba102abea3e3d0e4.js" async=""></script><script src="/_next/static/chunks/app/%5Bslug%5D/page-a8d66757df33bd31.js" async=""></script><title>What I learned writing a LISP Interpreter - Matt&#x27;s Blog</title><meta name="description" content="A blog about coding, travel, and life."/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body id="main" class="main px-5 pb-10 max-w-5xl m-auto"><div hidden=""><!--$--><!--/$--></div><div><div class="flex flex-wrap p-1 sm:p-3"><a class="mx-3 p-1 sm:px-3 sm:py-2 rounded-lg hover:bg-gray-200 transition-all font-bold" href="/">Blog</a><a class="mx-3 p-1 sm:px-3 sm:py-2 rounded-lg hover:bg-gray-200 transition-all font-normal" href="/projects/">Projects</a><a class="mx-3 p-1 sm:px-3 sm:py-2 rounded-lg hover:bg-gray-200 transition-all font-normal" href="/travel/">Travel</a><a class="mx-3 p-1 sm:px-3 sm:py-2 rounded-lg hover:bg-gray-200 transition-all font-normal" href="/about/">About Me</a><a class="mx-3 p-1 sm:px-3 sm:py-2 rounded-lg hover:bg-gray-200 transition-all " target="_blank" href="https://docs.google.com/forms/d/e/1FAIpQLScM11T5L9SjhZ1c9A3OB7aWc6DuLYTzf9DStnFkalDKaKDpaA/viewform?usp=sharing&amp;ouid=112011499277324502181">Contact</a></div><div class="md:flex md:justify-center"><article class="prose md:prose-lg lg:prose-xl mt-16"><h1 class="mb-0">What I learned writing a LISP Interpreter</h1><div class="text-gray-400">December 27, 2021</div><div class="mt-6"><h2>Why LISP?</h2>
<p>After being reminded of <a href="https://adventofcode.com" target="_blank" class="underline">Advent of Code</a> at the beginning of this month,
I decided to start participating in it.
I knew of this site before, but in the past I learned of it <em>after</em> the event was already over.
One thing I love about these types of programming challenges is seeing
the solutions that other people come up with and the approach they take to solving the problems.</p>
<p>Python is my go-to language for solving these types of problems.
No other language that I know of does a better job at getting out of my way
and letting me focus 100% on the problem at hand.
When thinking about the programming languages that I prefer, I naturally ask myself a few questions:
What exactly makes a programming language more fun to use than another?
What makes you appreciate one programming language more than another?</p>
<p>I love reading about programming languages.
One of my favorite (historic) blogs to read is that of <a href="https://en.wikipedia.org/wiki/Andy_Gavin" target="_blank" class="underline">Andy Gavin</a>,
who was one of the founders and lead programmer at Naughty Dog Games.
He is someone who was also <a href="https://all-things-andy-gavin.com/2011/03/12/making-crash-bandicoot-gool-part-9/" target="_blank" class="underline">fascinated by the power of programming languages</a>,
so much so that he even designed a compiler for his own LISP-like language called <a href="https://en.wikipedia.org/wiki/Game_Oriented_Assembly_Lisp" target="_blank" class="underline">GOAL</a>
and then proceeded to write multiple best-selling PS2 games using it.
Seeing as Advent of Code puzzles provide a good opportunity to learn a new language,
I decided that I wanted to try and solve a few with LISP.
This was also inspired by projects like <a href="https://github.com/water111/jak-project" target="_blank" class="underline">Open GOAL</a> which
are reverse engineering Gavin&#x27;s custom LISP dialect.
It is all just fascinating to me.</p>
<p>Writing a LISP interpreter took me down a fun rabbit hole of computer science and programming language design and implementation that I would like to share a little bit about with you.</p>
<h2>Writing an Interpreter</h2>
<p>Firstly, I would like to recommend Robert Nystrom&#x27;s &quot;<a href="https://craftinginterpreters.com/" target="_blank" class="underline">Crafting Interpreters</a>&quot;,
which is a free (and amazingly high quality) book about implementing an interpreter for a programming language.
I referenced this book quite a bit.</p>
<p>My LISP journey was broken down into 3 main parts:</p>
<h3>Tokenizing</h3>
<p>The first part of writing a language is tokenizing.
This is breaking down the source text of a file into
individual bite-sized pieces that correspond to something meaningful in the language.
It&#x27;s up to you to decide the grouping of words and text corresponds to meaning in your language.</p>
<p>For example, the source text:</p>
<pre><code class="hljs language-lisp">(<span class="hljs-name">define</span> square (<span class="hljs-name">lambda</span> (<span class="hljs-name">n</span>)
    (<span class="hljs-name">*</span> n n)))
</code></pre>
<p>Would become a list of tokens, with each having its own type assigned to it:</p>
<pre><code class="hljs language-nginx"><span class="hljs-attribute">Found</span> <span class="hljs-number">15</span> tokens in total.
<span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-string">&#x27;define&#x27;</span> <span class="hljs-string">&#x27;square&#x27;</span> <span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-string">&#x27;lambda&#x27;</span> <span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-string">&#x27;n&#x27;</span> <span class="hljs-string">&#x27;)&#x27;</span> <span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-string">&#x27;*&#x27;</span> <span class="hljs-string">&#x27;n&#x27;</span> <span class="hljs-string">&#x27;n&#x27;</span> <span class="hljs-string">&#x27;)&#x27;</span> <span class="hljs-string">&#x27;)&#x27;</span> <span class="hljs-string">&#x27;)&#x27;</span>
</code></pre>
<p>Things like whitespace and line breaks are effectively ignored, as they don&#x27;t have
any meaning in the language.
Reading in the tokens was as simple as looping through a list of regular expressions
and detecting the first one that matches the beginning part of the source file:</p>
<pre><code class="hljs language-cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tokenRegex</span> tokenRegexes[] = {
    { TokenType::WHITESPACE, <span class="hljs-string">&quot;[\\s,]+&quot;</span> },
    { TokenType::COMMENT, <span class="hljs-string">&quot;;.+&quot;</span> },
    { TokenType::PAREN_LEFT, <span class="hljs-string">&quot;\\(&quot;</span> },
    { TokenType::PAREN_RIGHT, <span class="hljs-string">&quot;\\)&quot;</span> },
    { TokenType::QUOTE, <span class="hljs-string">&quot;\&#x27;&quot;</span> },
    { TokenType::BOOLEAN, <span class="hljs-string">&quot;false&quot;</span> },
    { TokenType::BOOLEAN, <span class="hljs-string">&quot;true&quot;</span> },
    { TokenType::SYMBOL_NUMBER, <span class="hljs-string">&quot;[^\\s\\[\\]{}(&#x27;\&quot;`,;)]+&quot;</span> },
    { TokenType::STRING, <span class="hljs-string">&quot;\\\&quot;.*\\\&quot;&quot;</span> }
};
</code></pre>
<p>When a pattern is matched, a <code>Token</code> is created, given a type, and the matched part of the source
string is set to the content of that token.
When this is done, you have an entire list of all tokens in the source program,
which leads to:</p>
<h3>Parsing</h3>
<p>Parsing is the step where the data in individual tokens are used to build
what I called <code>Expr</code>s, or Expressions.
In LISP and functional languages, everything is an expression.
An expression object could take one of a few forms.
In my implementation, an expression can be a <code>Number</code>, <code>Symbol</code>, <code>Boolean</code>, or <code>List</code>.</p>
<pre><code class="hljs language-cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Expr</span>
{
    ExprType type;

    <span class="hljs-keyword">union</span> <span class="hljs-title class_">as</span>
    {
        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ExprSymbol</span> symbol;
        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ExprNumber</span> number;
        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ExprList</span> list;
        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ExprBool</span> boolean;
    } as;
} Expr;
</code></pre>
<p>The job of the parser is to start at the beginning of the token list,
and use those tokens to construct individual expressions.
For example, if we see a number token, we simply set the type of expression
to <code>Number</code>, and then convert the string value of the number into its integer
equivalent.
The same thing is done for symbols and booleans, but lists are a bit different.
A list expression can be implemented as a dynamically sized array of expressions.
Creating and populating a list expression is done by recursively parsing expressions
and adding it to the list:</p>
<pre><code class="hljs language-cpp"><span class="hljs-built_in">consume</span>(TokenType::PAREN_LEFT, <span class="hljs-string">&quot;Expected (, found &quot;</span> + token.content);
expr-&gt;type = ExprType::List;

<span class="hljs-keyword">while</span> (<span class="hljs-built_in">check</span>(TokenType::PAREN_RIGHT) == <span class="hljs-literal">false</span>)
{
    <span class="hljs-keyword">auto</span> temp = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">parse</span>();
    expr-&gt;as.list.exprs-&gt;<span class="hljs-built_in">push_back</span>(temp);
}

<span class="hljs-built_in">consume</span>(TokenType::PAREN_RIGHT, <span class="hljs-string">&quot;Expected ), found &quot;</span> + token.content);
</code></pre>
<p>When parsing is done, you&#x27;re left with a list of Expressions that form your program!
All that&#x27;s left to do is evaluate them.</p>
<h3>Evaluation</h3>
<p>Evaluation is taking an expression and converting it to its most primitive evaluated form.
Consider the expression <code>(+ 1 2)</code>, after calling <code>eval</code> on this, we would get a new expression <code>3</code>.
Numbers and booleans evaluate to themselves.
Symbols are simply variables, so their value is determined by doing a lookup of the symbol name
and returning whatever expression it has assigned to it.</p>
<p>Lists are the most complicated type to evaluate.
in LISP, the first item in a list is always considered a name of a function to call,
and the rest of the items in the list are considered its arguments.
This is where evaluating gets interesting.
Consider <code>(square 4)</code>. How would this be evaluated?</p>
<pre><code class="hljs language-lisp">(<span class="hljs-name">define</span> square (<span class="hljs-name">lambda</span> (<span class="hljs-name">n</span>) (<span class="hljs-name">*</span> n n)))
<span class="hljs-comment">; the symbol &#x27;square&#x27; will now return a list: (lambda (n) (* n n)) when evaluated.</span>

(<span class="hljs-name">square</span> <span class="hljs-number">4</span>)
<span class="hljs-comment">; can be also understood as:</span>
((<span class="hljs-name">lambda</span> (<span class="hljs-name">n</span>) (<span class="hljs-name">*</span> n n)) <span class="hljs-number">4</span>)
</code></pre>
<p>Now before each function call, you must create a new variable environment which maps
the function arguments to the symbols given as the function parameters.</p>
<pre><code class="hljs language-lisp">((<span class="hljs-name">lambda</span> (<span class="hljs-name">n</span>) (<span class="hljs-name">*</span> n n)) <span class="hljs-number">4</span>)
<span class="hljs-comment">; becomes</span>
((<span class="hljs-name">lambda</span> (<span class="hljs-name">n</span>) (<span class="hljs-name">*</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span>))) <span class="hljs-comment">; since n = 4</span>
<span class="hljs-comment">; or most simply</span>
(<span class="hljs-name">*</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span>)

<span class="hljs-comment">; so</span>
(<span class="hljs-name">square</span> <span class="hljs-number">4</span>)
<span class="hljs-comment">; has become</span>
(<span class="hljs-name">*</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span>)
<span class="hljs-comment">; or just</span>
<span class="hljs-number">16</span>
</code></pre>
<p>All functions are defined by the user, but there are some special functions which
the language implementation must provide in order to make the language useful
to begin with.
For my implementation, I wrote custom code for the following functions:</p>
<p><code>+ - * / &gt; lambda define quote if car cdr cons empty?</code></p>
<p>This gives the user of the language access to many helpful standard functions
that they can use to build their programs.
Now they can perform arithmetic on numbers, compare numbers, define functions,
get the <code>first</code> and <code>rest</code> of a list, use an <code>if</code> statement, and tell if a list is empty.
You might wonder why I only implemented <code>&gt;</code> and not <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>=</code>, etc.?
The answer to this is quite fun: You can actually implement these functions in the LISP language itself,
being bootstrapped by the single <code>&gt;</code> boolean operator:</p>
<pre><code class="hljs language-lisp">(<span class="hljs-name">define</span> &lt; (<span class="hljs-name">lambda</span> (<span class="hljs-name">a</span> b) (<span class="hljs-name">&gt;</span> b a)))

(<span class="hljs-name">define</span> = (<span class="hljs-name">lambda</span> (<span class="hljs-name">a</span> b) (<span class="hljs-name">if</span> (<span class="hljs-name">&gt;</span> a b) false
    (<span class="hljs-name">if</span> (<span class="hljs-name">&lt;</span> a b) false true))))

(<span class="hljs-name">define</span> &gt;= (<span class="hljs-name">lambda</span> (<span class="hljs-name">a</span> b) (<span class="hljs-name">if</span> (<span class="hljs-name">&gt;</span> a b) true
    (<span class="hljs-name">if</span> (<span class="hljs-name">=</span> a b) true false))))

(<span class="hljs-name">define</span> &lt;= (<span class="hljs-name">lambda</span> (<span class="hljs-name">a</span> b) (<span class="hljs-name">&gt;=</span> b a)))
</code></pre>
<p>Using basic primitives and fleshing out a little standard library in the language you just created
is one of the most magical feelings while creating a language!
It&#x27;s like watching Frankenstein&#x27;s monster come to life.</p>
<h2>Using My Language</h2>
<p>Although this little LISP language is just a toy, I was curious as to how effective it was.
Could I actually use this to solve a real problem?
I looked at the Advent of Code problems that I had yet to solve, and chose <a href="https://adventofcode.com/2021/day/17" target="_blank" class="underline">Day 17</a>.
This looked like the perfect problem to try and solve in my language.
The puzzle input is just 4 numbers, so there&#x27;s no need for dealing with files, parsing strings, etc.
The question itself appeared to be centered around numbers and math, not around string manipulation as some other puzzles are.</p>
<p>After spending some time on the problem and slowly fleshing out my standard library with generic functions as I needed them,
I was finally able to solve Part 1 in my own language!
What was even more shocking was that it honestly <em>wasn&#x27;t that bad</em> to use.
Implementing functions like <code>map</code> and <code>filter</code> is a breeze in LISP:</p>
<pre><code class="hljs language-lisp">(<span class="hljs-name">define</span> filter (<span class="hljs-name">lambda</span> (<span class="hljs-name">fn</span> xs acc)
    (<span class="hljs-name">if</span> (<span class="hljs-name">empty</span>? xs) acc
        (<span class="hljs-name">if</span> (<span class="hljs-name">fn</span> (<span class="hljs-name">car</span> xs))
            (<span class="hljs-name">filter</span> fn (<span class="hljs-name">cdr</span> xs) (<span class="hljs-name">cons</span> (<span class="hljs-name">car</span> xs) acc))
            (<span class="hljs-name">filter</span> fn (<span class="hljs-name">cdr</span> xs) acc)))))
</code></pre>
<p>So after writing a few basic functions like <code>map</code>, <code>filter</code>, <code>range</code>, and <code>max</code>,
solving the problem was actually quite enjoyable!
It felt a lot like using python&#x27;s functional list features to solve problems.
I didn&#x27;t feel like I was fighting the language very much.
Considering how basic my implementation was at that point,
not feeling too constrained by my primitive language and being able to easily write helper functions
is a testament to the power of LISP.</p>
<p>Here is the code I wrote that earned me my first star for Day 17:</p>
<pre><code class="hljs language-lisp"><span class="hljs-comment">; target area: x=288..330, y=-96..-50</span>
(<span class="hljs-name">define</span> xMin <span class="hljs-number">288</span>)
(<span class="hljs-name">define</span> xMax <span class="hljs-number">330</span>)
(<span class="hljs-name">define</span> yMin <span class="hljs-number">-96</span>)
(<span class="hljs-name">define</span> yMax <span class="hljs-number">-50</span>)

(<span class="hljs-name">define</span> inBounds (<span class="hljs-name">lambda</span> (<span class="hljs-name">x</span> y)
    (<span class="hljs-name">and</span> (<span class="hljs-name">inX</span> x) (<span class="hljs-name">inY</span> y))))

(<span class="hljs-name">define</span> inX (<span class="hljs-name">lambda</span> (<span class="hljs-name">x</span>)
    (<span class="hljs-name">and</span> (<span class="hljs-name">&gt;=</span> x xMin) (<span class="hljs-name">and</span> (<span class="hljs-name">&lt;=</span> x xMax) true))))

(<span class="hljs-name">define</span> inY (<span class="hljs-name">lambda</span> (<span class="hljs-name">y</span>)
    (<span class="hljs-name">and</span> (<span class="hljs-name">&gt;=</span> y yMin) (<span class="hljs-name">and</span> (<span class="hljs-name">&lt;=</span> y yMax) true))))

(<span class="hljs-name">define</span> pastX (<span class="hljs-name">lambda</span> (<span class="hljs-name">x</span>) (<span class="hljs-name">&gt;</span> x xMax)))
(<span class="hljs-name">define</span> pastY (<span class="hljs-name">lambda</span> (<span class="hljs-name">y</span>) (<span class="hljs-name">&lt;</span> y yMin)))
(<span class="hljs-name">define</span> pastBounds (<span class="hljs-name">lambda</span> (<span class="hljs-name">x</span> y) (<span class="hljs-name">or</span> (<span class="hljs-name">pastX</span> x) (<span class="hljs-name">pastY</span> y))))

(<span class="hljs-name">define</span> step (<span class="hljs-name">lambda</span> (<span class="hljs-name">x</span> y xVel yVel peak steps)
    <span class="hljs-comment">; if we have hit our magic area, return highest peak</span>
    (<span class="hljs-name">if</span> (<span class="hljs-name">inBounds</span> x y) peak
        <span class="hljs-comment">; if we are past the bounds, return FAIL</span>
        (<span class="hljs-name">if</span> (<span class="hljs-name">pastBounds</span> x y) <span class="hljs-number">-1</span>
            <span class="hljs-comment">; otherwise, do the next step</span>
            (<span class="hljs-name">step</span>
                (<span class="hljs-name">+</span> x xVel)
                (<span class="hljs-name">+</span> y yVel)
                (<span class="hljs-name">if</span> (<span class="hljs-name">&gt;</span> xVel <span class="hljs-number">0</span>) (<span class="hljs-name">-</span> xVel <span class="hljs-number">1</span>)
                    (<span class="hljs-name">if</span> (<span class="hljs-name">&lt;</span> xVel <span class="hljs-number">0</span>) (<span class="hljs-name">+</span> xVel <span class="hljs-number">1</span>) <span class="hljs-number">0</span>))
                (<span class="hljs-name">-</span> yVel <span class="hljs-number">1</span>)
                (<span class="hljs-name">if</span> (<span class="hljs-name">&gt;</span> y peak) y peak)
                (<span class="hljs-name">+</span> <span class="hljs-number">1</span> steps))))))

(<span class="hljs-name">define</span> shoot (<span class="hljs-name">lambda</span> (<span class="hljs-name">xVel</span> yVel) (<span class="hljs-name">step</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> xVel yVel <span class="hljs-number">0</span> <span class="hljs-number">0</span>)))

(<span class="hljs-name">define</span> xVelDist (<span class="hljs-name">lambda</span> (<span class="hljs-name">x</span>) (<span class="hljs-name">if</span> (<span class="hljs-name">&lt;=</span> x <span class="hljs-number">1</span>) x
    (<span class="hljs-name">+</span> x (<span class="hljs-name">xVelDist</span> (<span class="hljs-name">-</span> x <span class="hljs-number">1</span>))))))

(<span class="hljs-name">define</span> range (<span class="hljs-name">lambda</span> (<span class="hljs-name">from</span> to acc) (<span class="hljs-name">if</span> (<span class="hljs-name">=</span> from (<span class="hljs-name">+</span> <span class="hljs-number">1</span> to)) acc
    (<span class="hljs-name">range</span> (<span class="hljs-name">+</span> from <span class="hljs-number">1</span>) to (<span class="hljs-name">cons</span> (<span class="hljs-name">-</span> to from) acc)))))

(<span class="hljs-name">define</span> testRange (<span class="hljs-name">range</span> <span class="hljs-number">0</span> <span class="hljs-number">100</span> &#x27;()))
(<span class="hljs-name">define</span> searchY (<span class="hljs-name">range</span> <span class="hljs-number">0</span> <span class="hljs-number">100</span> &#x27;()))

(<span class="hljs-name">define</span> peaks (<span class="hljs-name">lambda</span> (<span class="hljs-name">x</span>) (<span class="hljs-name">&gt;</span> x <span class="hljs-number">0</span>)))

(<span class="hljs-name">define</span> searchX (<span class="hljs-name">filter</span> (<span class="hljs-name">lambda</span> (<span class="hljs-name">x</span>) (<span class="hljs-name">inX</span> (<span class="hljs-name">xVelDist</span> x))) testRange))

(<span class="hljs-name">define</span> maxAtX (<span class="hljs-name">lambda</span> (<span class="hljs-name">x</span>)
    (<span class="hljs-name">max</span> (<span class="hljs-name">filter</span> peaks (<span class="hljs-name">map</span> (<span class="hljs-name">lambda</span> (<span class="hljs-name">y</span>) (<span class="hljs-name">shoot</span> x y)) searchY)) <span class="hljs-number">0</span>)))

(<span class="hljs-name">max</span> (<span class="hljs-name">map</span> maxAtX searchX) <span class="hljs-number">0</span>)
</code></pre>
<p>What more can you ask for from a project like this?
I implemented a programming language and then used it to solve a real problem.
It was a really good feeling getting the right answer using a tool that you made yourself!</p>
<h2>Takeaways</h2>
<p>LISP is a language that is timeless.
Getting my feet wet in writing an interpreter for LISP has taught me
a lot about the fundamentals of creating a programming language.
For its simplicity, writing LISP feels incredibly powerful.
Although it is dated now, I could see myself loving LISP if I were a programmer
back in the 80&#x27;s and 90&#x27;s.
Most of the languages we take for granted today weren&#x27;t around back then,
or were in their infancy and not very practical to use.
Imagine having a language like LISP where you could warp it into whatever
you wanted it to be!</p>
<blockquote>
<p>Python reached version 1.0 in January 1994. The major new features included in this release were the functional programming tools lambda, map, filter and reduce. Van Rossum stated that &quot;Python acquired lambda, reduce(), filter() and map(), courtesy of a Lisp hacker who missed them and submitted working patches&quot;.</p>
</blockquote>
<p><img src="https://imgs.xkcd.com/comics/lisp_cycles.png" alt=""/></p>
<p><a href="https://github.com/mattbruv/mplisp" target="_blank" class="underline">Source code for mplisp</a>.</p></div></article></div></div><!--$--><!--/$--><script src="/_next/static/chunks/webpack-6b8b512d4121474e.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[9766,[],\"\"]\n3:I[8924,[],\"\"]\n5:I[4431,[],\"OutletBoundary\"]\n7:I[5278,[],\"AsyncMetadataOutlet\"]\n9:I[4431,[],\"ViewportBoundary\"]\nb:I[4431,[],\"MetadataBoundary\"]\nc:\"$Sreact.suspense\"\ne:I[7150,[],\"\"]\n:HL[\"/_next/static/css/0f63a619df29c78b.css\",\"style\"]\n:HL[\"/_next/static/css/5eacd01f773eed7f.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"lLKmyGbgC9GZXyGPxKThQ\",\"p\":\"\",\"c\":[\"\",\"mplisp\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[[\"slug\",\"mplisp\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/0f63a619df29c78b.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"charSet\":\"UTF-8\"}],[\"$\",\"meta\",null,{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1.0\"}]]}],[\"$\",\"body\",null,{\"id\":\"main\",\"className\":\"main px-5 pb-10 max-w-5xl m-auto\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}]]}],{\"children\":[[\"slug\",\"mplisp\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/5eacd01f773eed7f.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"$L5\",null,{\"children\":[\"$L6\",[\"$\",\"$L7\",null,{\"promise\":\"$@8\"}]]}]]}],{},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[[\"$\",\"$L9\",null,{\"children\":\"$La\"}],null],[\"$\",\"$Lb\",null,{\"children\":[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$c\",null,{\"fallback\":null,\"children\":\"$Ld\"}]}]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$e\",[]],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n6:null\n"])</script><script>self.__next_f.push([1,"f:I[2619,[\"619\",\"static/chunks/619-ba102abea3e3d0e4.js\",\"182\",\"static/chunks/app/%5Bslug%5D/page-a8d66757df33bd31.js\"],\"\"]\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"children\":[[\"$\",\"div\",null,{\"className\":\"flex flex-wrap p-1 sm:p-3\",\"children\":[[[\"$\",\"$Lf\",\"0\",{\"className\":\"mx-3 p-1 sm:px-3 sm:py-2 rounded-lg hover:bg-gray-200 transition-all font-bold\",\"href\":\"/\",\"children\":\"Blog\"}],[\"$\",\"$Lf\",\"1\",{\"className\":\"mx-3 p-1 sm:px-3 sm:py-2 rounded-lg hover:bg-gray-200 transition-all font-normal\",\"href\":\"/projects\",\"children\":\"Projects\"}],[\"$\",\"$Lf\",\"2\",{\"className\":\"mx-3 p-1 sm:px-3 sm:py-2 rounded-lg hover:bg-gray-200 transition-all font-normal\",\"href\":\"/travel\",\"children\":\"Travel\"}],[\"$\",\"$Lf\",\"3\",{\"className\":\"mx-3 p-1 sm:px-3 sm:py-2 rounded-lg hover:bg-gray-200 transition-all font-normal\",\"href\":\"/about\",\"children\":\"About Me\"}]],[\"$\",\"$Lf\",\"contact\",{\"className\":\"mx-3 p-1 sm:px-3 sm:py-2 rounded-lg hover:bg-gray-200 transition-all \",\"target\":\"_blank\",\"href\":\"https://docs.google.com/forms/d/e/1FAIpQLScM11T5L9SjhZ1c9A3OB7aWc6DuLYTzf9DStnFkalDKaKDpaA/viewform?usp=sharing\u0026ouid=112011499277324502181\",\"children\":\"Contact\"}]]}],[\"$\",\"div\",null,{\"className\":\"md:flex md:justify-center\",\"children\":[\"$\",\"article\",null,{\"className\":\"prose md:prose-lg lg:prose-xl mt-16\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"mb-0\",\"children\":\"What I learned writing a LISP Interpreter\"}],null,[\"$\",\"div\",null,{\"className\":\"text-gray-400\",\"children\":\"December 27, 2021\"}],[\"$\",\"div\",null,{\"className\":\"mt-6\",\"children\":[[\"$\",\"h2\",null,{\"children\":\"Why LISP?\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"After being reminded of \",[\"$\",\"a\",null,{\"href\":\"https://adventofcode.com\",\"target\":\"_blank\",\"className\":\"underline\",\"children\":\"Advent of Code\"}],\" at the beginning of this month,\\nI decided to start participating in it.\\nI knew of this site before, but in the past I learned of it \",[\"$\",\"em\",null,{\"children\":\"after\"}],\" the event was already over.\\nOne thing I love about these types of programming challenges is seeing\\nthe solutions that other people come up with and the approach they take to solving the problems.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Python is my go-to language for solving these types of problems.\\nNo other language that I know of does a better job at getting out of my way\\nand letting me focus 100% on the problem at hand.\\nWhen thinking about the programming languages that I prefer, I naturally ask myself a few questions:\\nWhat exactly makes a programming language more fun to use than another?\\nWhat makes you appreciate one programming language more than another?\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"I love reading about programming languages.\\nOne of my favorite (historic) blogs to read is that of \",[\"$\",\"a\",null,{\"href\":\"https://en.wikipedia.org/wiki/Andy_Gavin\",\"target\":\"_blank\",\"className\":\"underline\",\"children\":\"Andy Gavin\"}],\",\\nwho was one of the founders and lead programmer at Naughty Dog Games.\\nHe is someone who was also \",[\"$\",\"a\",null,{\"href\":\"https://all-things-andy-gavin.com/2011/03/12/making-crash-bandicoot-gool-part-9/\",\"target\":\"_blank\",\"className\":\"underline\",\"children\":\"fascinated by the power of programming languages\"}],\",\\nso much so that he even designed a compiler for his own LISP-like language called \",[\"$\",\"a\",null,{\"href\":\"https://en.wikipedia.org/wiki/Game_Oriented_Assembly_Lisp\",\"target\":\"_blank\",\"className\":\"underline\",\"children\":\"GOAL\"}],\"\\nand then proceeded to write multiple best-selling PS2 games using it.\\nSeeing as Advent of Code puzzles provide a good opportunity to learn a new language,\\nI decided that I wanted to try and solve a few with LISP.\\nThis was also inspired by projects like \",[\"$\",\"a\",null,{\"href\":\"https://github.com/water111/jak-project\",\"target\":\"_blank\",\"className\":\"underline\",\"children\":\"Open GOAL\"}],\" which\\nare reverse engineering Gavin's custom LISP dialect.\\nIt is all just fascinating to me.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Writing a LISP interpreter took me down a fun rabbit hole of computer science and programming language design and implementation that I would like to share a little bit about with you.\"}],\"\\n\",\"$L10\",\"\\n\",\"$L11\",\"\\n\",\"$L12\",\"\\n\",\"$L13\",\"\\n\",\"$L14\",\"\\n\",\"$L15\",\"\\n\",\"$L16\",\"\\n\",\"$L17\",\"\\n\",\"$L18\",\"\\n\",\"$L19\",\"\\n\",\"$L1a\",\"\\n\",\"$L1b\",\"\\n\",\"$L1c\",\"\\n\",\"$L1d\",\"\\n\",\"$L1e\",\"\\n\",\"$L1f\",\"\\n\",\"$L20\",\"\\n\",\"$L21\",\"\\n\",\"$L22\",\"\\n\",\"$L23\",\"\\n\",\"$L24\",\"\\n\",\"$L25\",\"\\n\",\"$L26\",\"\\n\",\"$L27\",\"\\n\",\"$L28\",\"\\n\",\"$L29\",\"\\n\",\"$L2a\",\"\\n\",\"$L2b\",\"\\n\",\"$L2c\",\"\\n\",\"$L2d\",\"\\n\",\"$L2e\",\"\\n\",\"$L2f\",\"\\n\",\"$L30\",\"\\n\",\"$L31\",\"\\n\",\"$L32\",\"\\n\",\"$L33\",\"\\n\",\"$L34\",\"\\n\",\"$L35\",\"\\n\",\"$L36\",\"\\n\",\"$L37\",\"\\n\",\"$L38\",\"\\n\",\"$L39\"]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"8:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"What I learned writing a LISP Interpreter - Matt's Blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"A blog about coding, travel, and life.\"}]],\"error\":null,\"digest\":\"$undefined\"}\nd:\"$8:metadata\"\n"])</script><script>self.__next_f.push([1,"10:[\"$\",\"h2\",null,{\"children\":\"Writing an Interpreter\"}]\n11:[\"$\",\"p\",null,{\"children\":[\"Firstly, I would like to recommend Robert Nystrom's \\\"\",[\"$\",\"a\",null,{\"href\":\"https://craftinginterpreters.com/\",\"target\":\"_blank\",\"className\":\"underline\",\"children\":\"Crafting Interpreters\"}],\"\\\",\\nwhich is a free (and amazingly high quality) book about implementing an interpreter for a programming language.\\nI referenced this book quite a bit.\"]}]\n12:[\"$\",\"p\",null,{\"children\":\"My LISP journey was broken down into 3 main parts:\"}]\n13:[\"$\",\"h3\",null,{\"children\":\"Tokenizing\"}]\n14:[\"$\",\"p\",null,{\"children\":\"The first part of writing a language is tokenizing.\\nThis is breaking down the source text of a file into\\nindividual bite-sized pieces that correspond to something meaningful in the language.\\nIt's up to you to decide the grouping of words and text corresponds to meaning in your language.\"}]\n15:[\"$\",\"p\",null,{\"children\":\"For example, the source text:\"}]\n16:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-lisp\",\"children\":[\"(\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"define\"}],\" square (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"lambda\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"n\"}],\")\\n    (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"*\"}],\" n n)))\\n\"]}]}]\n17:[\"$\",\"p\",null,{\"children\":\"Would become a list of tokens, with each having its own type assigned to it:\"}]\n"])</script><script>self.__next_f.push([1,"18:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-nginx\",\"children\":[[\"$\",\"span\",null,{\"className\":\"hljs-attribute\",\"children\":\"Found\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"15\"}],\" tokens in total.\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"'('\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"'define'\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"'square'\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"'('\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"'lambda'\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"'('\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"'n'\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"')'\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"'('\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"'*'\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"'n'\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"'n'\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"')'\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"')'\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"')'\"}],\"\\n\"]}]}]\n"])</script><script>self.__next_f.push([1,"19:[\"$\",\"p\",null,{\"children\":\"Things like whitespace and line breaks are effectively ignored, as they don't have\\nany meaning in the language.\\nReading in the tokens was as simple as looping through a list of regular expressions\\nand detecting the first one that matches the beginning part of the source file:\"}]\n"])</script><script>self.__next_f.push([1,"1a:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-cpp\",\"children\":[[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"struct\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-title class_\",\"children\":\"tokenRegex\"}],\" tokenRegexes[] = {\\n    { TokenType::WHITESPACE, \",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"\\\"[\\\\\\\\s,]+\\\"\"}],\" },\\n    { TokenType::COMMENT, \",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"\\\";.+\\\"\"}],\" },\\n    { TokenType::PAREN_LEFT, \",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"\\\"\\\\\\\\(\\\"\"}],\" },\\n    { TokenType::PAREN_RIGHT, \",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"\\\"\\\\\\\\)\\\"\"}],\" },\\n    { TokenType::QUOTE, \",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"\\\"\\\\'\\\"\"}],\" },\\n    { TokenType::BOOLEAN, \",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"\\\"false\\\"\"}],\" },\\n    { TokenType::BOOLEAN, \",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"\\\"true\\\"\"}],\" },\\n    { TokenType::SYMBOL_NUMBER, \",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"\\\"[^\\\\\\\\s\\\\\\\\[\\\\\\\\]{}('\\\\\\\"`,;)]+\\\"\"}],\" },\\n    { TokenType::STRING, \",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"\\\"\\\\\\\\\\\\\\\".*\\\\\\\\\\\\\\\"\\\"\"}],\" }\\n};\\n\"]}]}]\n"])</script><script>self.__next_f.push([1,"1b:[\"$\",\"p\",null,{\"children\":[\"When a pattern is matched, a \",[\"$\",\"code\",null,{\"children\":\"Token\"}],\" is created, given a type, and the matched part of the source\\nstring is set to the content of that token.\\nWhen this is done, you have an entire list of all tokens in the source program,\\nwhich leads to:\"]}]\n1c:[\"$\",\"h3\",null,{\"children\":\"Parsing\"}]\n1d:[\"$\",\"p\",null,{\"children\":[\"Parsing is the step where the data in individual tokens are used to build\\nwhat I called \",[\"$\",\"code\",null,{\"children\":\"Expr\"}],\"s, or Expressions.\\nIn LISP and functional languages, everything is an expression.\\nAn expression object could take one of a few forms.\\nIn my implementation, an expression can be a \",[\"$\",\"code\",null,{\"children\":\"Number\"}],\", \",[\"$\",\"code\",null,{\"children\":\"Symbol\"}],\", \",[\"$\",\"code\",null,{\"children\":\"Boolean\"}],\", or \",[\"$\",\"code\",null,{\"children\":\"List\"}],\".\"]}]\n"])</script><script>self.__next_f.push([1,"1e:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-cpp\",\"children\":[[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"typedef\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"struct\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-title class_\",\"children\":\"Expr\"}],\"\\n{\\n    ExprType type;\\n\\n    \",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"union\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-title class_\",\"children\":\"as\"}],\"\\n    {\\n        \",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"struct\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-title class_\",\"children\":\"ExprSymbol\"}],\" symbol;\\n        \",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"struct\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-title class_\",\"children\":\"ExprNumber\"}],\" number;\\n        \",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"struct\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-title class_\",\"children\":\"ExprList\"}],\" list;\\n        \",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"struct\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-title class_\",\"children\":\"ExprBool\"}],\" boolean;\\n    } as;\\n} Expr;\\n\"]}]}]\n"])</script><script>self.__next_f.push([1,"1f:[\"$\",\"p\",null,{\"children\":[\"The job of the parser is to start at the beginning of the token list,\\nand use those tokens to construct individual expressions.\\nFor example, if we see a number token, we simply set the type of expression\\nto \",[\"$\",\"code\",null,{\"children\":\"Number\"}],\", and then convert the string value of the number into its integer\\nequivalent.\\nThe same thing is done for symbols and booleans, but lists are a bit different.\\nA list expression can be implemented as a dynamically sized array of expressions.\\nCreating and populating a list expression is done by recursively parsing expressions\\nand adding it to the list:\"]}]\n"])</script><script>self.__next_f.push([1,"20:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-cpp\",\"children\":[[\"$\",\"span\",null,{\"className\":\"hljs-built_in\",\"children\":\"consume\"}],\"(TokenType::PAREN_LEFT, \",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"\\\"Expected (, found \\\"\"}],\" + token.content);\\nexpr-\u003etype = ExprType::List;\\n\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"while\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-built_in\",\"children\":\"check\"}],\"(TokenType::PAREN_RIGHT) == \",[\"$\",\"span\",null,{\"className\":\"hljs-literal\",\"children\":\"false\"}],\")\\n{\\n    \",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"auto\"}],\" temp = \",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"this\"}],\"-\u003e\",[\"$\",\"span\",null,{\"className\":\"hljs-built_in\",\"children\":\"parse\"}],\"();\\n    expr-\u003eas.list.exprs-\u003e\",[\"$\",\"span\",null,{\"className\":\"hljs-built_in\",\"children\":\"push_back\"}],\"(temp);\\n}\\n\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-built_in\",\"children\":\"consume\"}],\"(TokenType::PAREN_RIGHT, \",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"\\\"Expected ), found \\\"\"}],\" + token.content);\\n\"]}]}]\n"])</script><script>self.__next_f.push([1,"21:[\"$\",\"p\",null,{\"children\":\"When parsing is done, you're left with a list of Expressions that form your program!\\nAll that's left to do is evaluate them.\"}]\n22:[\"$\",\"h3\",null,{\"children\":\"Evaluation\"}]\n23:[\"$\",\"p\",null,{\"children\":[\"Evaluation is taking an expression and converting it to its most primitive evaluated form.\\nConsider the expression \",[\"$\",\"code\",null,{\"children\":\"(+ 1 2)\"}],\", after calling \",[\"$\",\"code\",null,{\"children\":\"eval\"}],\" on this, we would get a new expression \",[\"$\",\"code\",null,{\"children\":\"3\"}],\".\\nNumbers and booleans evaluate to themselves.\\nSymbols are simply variables, so their value is determined by doing a lookup of the symbol name\\nand returning whatever expression it has assigned to it.\"]}]\n24:[\"$\",\"p\",null,{\"children\":[\"Lists are the most complicated type to evaluate.\\nin LISP, the first item in a list is always considered a name of a function to call,\\nand the rest of the items in the list are considered its arguments.\\nThis is where evaluating gets interesting.\\nConsider \",[\"$\",\"code\",null,{\"children\":\"(square 4)\"}],\". How would this be evaluated?\"]}]\n"])</script><script>self.__next_f.push([1,"25:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-lisp\",\"children\":[\"(\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"define\"}],\" square (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"lambda\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"n\"}],\") (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"*\"}],\" n n)))\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"; the symbol 'square' will now return a list: (lambda (n) (* n n)) when evaluated.\"}],\"\\n\\n(\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"square\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"4\"}],\")\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"; can be also understood as:\"}],\"\\n((\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"lambda\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"n\"}],\") (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"*\"}],\" n n)) \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"4\"}],\")\\n\"]}]}]\n"])</script><script>self.__next_f.push([1,"26:[\"$\",\"p\",null,{\"children\":\"Now before each function call, you must create a new variable environment which maps\\nthe function arguments to the symbols given as the function parameters.\"}]\n"])</script><script>self.__next_f.push([1,"27:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-lisp\",\"children\":[\"((\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"lambda\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"n\"}],\") (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"*\"}],\" n n)) \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"4\"}],\")\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"; becomes\"}],\"\\n((\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"lambda\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"n\"}],\") (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"*\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"4\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"4\"}],\"))) \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"; since n = 4\"}],\"\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"; or most simply\"}],\"\\n(\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"*\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"4\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"4\"}],\")\\n\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"; so\"}],\"\\n(\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"square\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"4\"}],\")\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"; has become\"}],\"\\n(\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"*\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"4\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"4\"}],\")\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"; or just\"}],\"\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"16\"}],\"\\n\"]}]}]\n"])</script><script>self.__next_f.push([1,"28:[\"$\",\"p\",null,{\"children\":\"All functions are defined by the user, but there are some special functions which\\nthe language implementation must provide in order to make the language useful\\nto begin with.\\nFor my implementation, I wrote custom code for the following functions:\"}]\n29:[\"$\",\"p\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"+ - * / \u003e lambda define quote if car cdr cons empty?\"}]}]\n"])</script><script>self.__next_f.push([1,"2a:[\"$\",\"p\",null,{\"children\":[\"This gives the user of the language access to many helpful standard functions\\nthat they can use to build their programs.\\nNow they can perform arithmetic on numbers, compare numbers, define functions,\\nget the \",[\"$\",\"code\",null,{\"children\":\"first\"}],\" and \",[\"$\",\"code\",null,{\"children\":\"rest\"}],\" of a list, use an \",[\"$\",\"code\",null,{\"children\":\"if\"}],\" statement, and tell if a list is empty.\\nYou might wonder why I only implemented \",[\"$\",\"code\",null,{\"children\":\"\u003e\"}],\" and not \",[\"$\",\"code\",null,{\"children\":\"\u003c\"}],\", \",[\"$\",\"code\",null,{\"children\":\"\u003c=\"}],\", \",[\"$\",\"code\",null,{\"children\":\"\u003e=\"}],\", \",[\"$\",\"code\",null,{\"children\":\"=\"}],\", etc.?\\nThe answer to this is quite fun: You can actually implement these functions in the LISP language itself,\\nbeing bootstrapped by the single \",[\"$\",\"code\",null,{\"children\":\"\u003e\"}],\" boolean operator:\"]}]\n"])</script><script>self.__next_f.push([1,"2b:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-lisp\",\"children\":[\"(\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"define\"}],\" \u003c (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"lambda\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"a\"}],\" b) (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"\u003e\"}],\" b a)))\\n\\n(\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"define\"}],\" = (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"lambda\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"a\"}],\" b) (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"if\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"\u003e\"}],\" a b) false\\n    (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"if\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"\u003c\"}],\" a b) false true))))\\n\\n(\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"define\"}],\" \u003e= (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"lambda\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"a\"}],\" b) (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"if\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"\u003e\"}],\" a b) true\\n    (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"if\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"=\"}],\" a b) true false))))\\n\\n(\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"define\"}],\" \u003c= (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"lambda\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"a\"}],\" b) (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"\u003e=\"}],\" b a)))\\n\"]}]}]\n"])</script><script>self.__next_f.push([1,"2c:[\"$\",\"p\",null,{\"children\":\"Using basic primitives and fleshing out a little standard library in the language you just created\\nis one of the most magical feelings while creating a language!\\nIt's like watching Frankenstein's monster come to life.\"}]\n2d:[\"$\",\"h2\",null,{\"children\":\"Using My Language\"}]\n"])</script><script>self.__next_f.push([1,"2e:[\"$\",\"p\",null,{\"children\":[\"Although this little LISP language is just a toy, I was curious as to how effective it was.\\nCould I actually use this to solve a real problem?\\nI looked at the Advent of Code problems that I had yet to solve, and chose \",[\"$\",\"a\",null,{\"href\":\"https://adventofcode.com/2021/day/17\",\"target\":\"_blank\",\"className\":\"underline\",\"children\":\"Day 17\"}],\".\\nThis looked like the perfect problem to try and solve in my language.\\nThe puzzle input is just 4 numbers, so there's no need for dealing with files, parsing strings, etc.\\nThe question itself appeared to be centered around numbers and math, not around string manipulation as some other puzzles are.\"]}]\n"])</script><script>self.__next_f.push([1,"2f:[\"$\",\"p\",null,{\"children\":[\"After spending some time on the problem and slowly fleshing out my standard library with generic functions as I needed them,\\nI was finally able to solve Part 1 in my own language!\\nWhat was even more shocking was that it honestly \",[\"$\",\"em\",null,{\"children\":\"wasn't that bad\"}],\" to use.\\nImplementing functions like \",[\"$\",\"code\",null,{\"children\":\"map\"}],\" and \",[\"$\",\"code\",null,{\"children\":\"filter\"}],\" is a breeze in LISP:\"]}]\n"])</script><script>self.__next_f.push([1,"30:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-lisp\",\"children\":[\"(\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"define\"}],\" filter (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"lambda\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"fn\"}],\" xs acc)\\n    (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"if\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"empty\"}],\"? xs) acc\\n        (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"if\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"fn\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"car\"}],\" xs))\\n            (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"filter\"}],\" fn (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"cdr\"}],\" xs) (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"cons\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"car\"}],\" xs) acc))\\n            (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"filter\"}],\" fn (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"cdr\"}],\" xs) acc)))))\\n\"]}]}]\n"])</script><script>self.__next_f.push([1,"31:[\"$\",\"p\",null,{\"children\":[\"So after writing a few basic functions like \",[\"$\",\"code\",null,{\"children\":\"map\"}],\", \",[\"$\",\"code\",null,{\"children\":\"filter\"}],\", \",[\"$\",\"code\",null,{\"children\":\"range\"}],\", and \",[\"$\",\"code\",null,{\"children\":\"max\"}],\",\\nsolving the problem was actually quite enjoyable!\\nIt felt a lot like using python's functional list features to solve problems.\\nI didn't feel like I was fighting the language very much.\\nConsidering how basic my implementation was at that point,\\nnot feeling too constrained by my primitive language and being able to easily write helper functions\\nis a testament to the power of LISP.\"]}]\n32:[\"$\",\"p\",null,{\"children\":\"Here is the code I wrote that earned me my first star for Day 17:\"}]\n"])</script><script>self.__next_f.push([1,"33:[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-lisp\",\"children\":[[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"; target area: x=288..330, y=-96..-50\"}],\"\\n(\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"define\"}],\" xMin \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"288\"}],\")\\n(\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"define\"}],\" xMax \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"330\"}],\")\\n(\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"define\"}],\" yMin \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"-96\"}],\")\\n(\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"define\"}],\" yMax \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"-50\"}],\")\\n\\n(\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"define\"}],\" inBounds (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"lambda\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"x\"}],\" y)\\n    (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"and\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"inX\"}],\" x) (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"inY\"}],\" y))))\\n\\n(\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"define\"}],\" inX (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"lambda\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"x\"}],\")\\n    (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"and\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"\u003e=\"}],\" x xMin) (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"and\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"\u003c=\"}],\" x xMax) true))))\\n\\n(\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"define\"}],\" inY (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"lambda\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"y\"}],\")\\n    (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"and\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"\u003e=\"}],\" y yMin) (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"and\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"\u003c=\"}],\" y yMax) true))))\\n\\n(\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"define\"}],\" pastX (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"lambda\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"x\"}],\") (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"\u003e\"}],\" x xMax)))\\n(\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"define\"}],\" pastY (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"lambda\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"y\"}],\") (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"\u003c\"}],\" y yMin)))\\n(\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"define\"}],\" pastBounds (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"lambda\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"x\"}],\" y) (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"or\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"pastX\"}],\" x) (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"pastY\"}],\" y))))\\n\\n(\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"define\"}],\" step (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"lambda\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"x\"}],\" y xVel yVel peak steps)\\n    \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"; if we have hit our magic area, return highest peak\"}],\"\\n    (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"if\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"inBounds\"}],\" x y) peak\\n        \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"; if we are past the bounds, return FAIL\"}],\"\\n        (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"if\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"pastBounds\"}],\" x y) \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"-1\"}],\"\\n            \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"; otherwise, do the next step\"}],\"\\n            (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"step\"}],\"\\n                (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"+\"}],\" x xVel)\\n                (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"+\"}],\" y yVel)\\n                (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"if\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"\u003e\"}],\" xVel \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0\"}],\") (\",[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"-\"}],\" xVel \",\"$L3a\",\")\\n                    (\",\"$L3b\",\" (\",\"$L3c\",\" xVel \",\"$L3d\",\") (\",\"$L3e\",\" xVel \",\"$L3f\",\") \",\"$L40\",\"))\\n                (\",\"$L41\",\" yVel \",\"$L42\",\")\\n                (\",\"$L43\",\" (\",\"$L44\",\" y peak) y peak)\\n                (\",\"$L45\",\" \",\"$L46\",\" steps))))))\\n\\n(\",\"$L47\",\" shoot (\",\"$L48\",\" (\",\"$L49\",\" yVel) (\",\"$L4a\",\" \",\"$L4b\",\" \",\"$L4c\",\" xVel yVel \",\"$L4d\",\" \",\"$L4e\",\")))\\n\\n(\",\"$L4f\",\" xVelDist (\",\"$L50\",\" (\",\"$L51\",\") (\",\"$L52\",\" (\",\"$L53\",\" x \",\"$L54\",\") x\\n    (\",\"$L55\",\" x (\",\"$L56\",\" (\",\"$L57\",\" x \",\"$L58\",\"))))))\\n\\n(\",\"$L59\",\" range (\",\"$L5a\",\" (\",\"$L5b\",\" to acc) (\",\"$L5c\",\" (\",\"$L5d\",\" from (\",\"$L5e\",\" \",\"$L5f\",\" to)) acc\\n    (\",\"$L60\",\" (\",\"$L61\",\" from \",\"$L62\",\") to (\",\"$L63\",\" (\",\"$L64\",\" to from) acc)))))\\n\\n(\",\"$L65\",\" testRange (\",\"$L66\",\" \",\"$L67\",\" \",\"$L68\",\" '()))\\n(\",\"$L69\",\" searchY (\",\"$L6a\",\" \",\"$L6b\",\" \",\"$L6c\",\" '()))\\n\\n(\",\"$L6d\",\" peaks (\",\"$L6e\",\" (\",\"$L6f\",\") (\",\"$L70\",\" x \",\"$L71\",\")))\\n\\n(\",\"$L72\",\" searchX (\",\"$L73\",\" (\",\"$L74\",\" (\",\"$L75\",\") (\",\"$L76\",\" (\",\"$L77\",\" x))) testRange))\\n\\n(\",\"$L78\",\" maxAtX (\",\"$L79\",\" (\",\"$L7a\",\")\\n    (\",\"$L7b\",\" (\",\"$L7c\",\" peaks (\",\"$L7d\",\" (\",\"$L7e\",\" (\",\"$L7f\",\") (\",\"$L80\",\" x y)) searchY)) \",\"$L81\",\")))\\n\\n(\",\"$L82\",\" (\",\"$L83\",\" maxAtX searchX) \",\"$L84\",\")\\n\"]}]}]\n"])</script><script>self.__next_f.push([1,"34:[\"$\",\"p\",null,{\"children\":\"What more can you ask for from a project like this?\\nI implemented a programming language and then used it to solve a real problem.\\nIt was a really good feeling getting the right answer using a tool that you made yourself!\"}]\n35:[\"$\",\"h2\",null,{\"children\":\"Takeaways\"}]\n36:[\"$\",\"p\",null,{\"children\":\"LISP is a language that is timeless.\\nGetting my feet wet in writing an interpreter for LISP has taught me\\na lot about the fundamentals of creating a programming language.\\nFor its simplicity, writing LISP feels incredibly powerful.\\nAlthough it is dated now, I could see myself loving LISP if I were a programmer\\nback in the 80's and 90's.\\nMost of the languages we take for granted today weren't around back then,\\nor were in their infancy and not very practical to use.\\nImagine having a language like LISP where you could warp it into whatever\\nyou wanted it to be!\"}]\n37:[\"$\",\"blockquote\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"Python reached version 1.0 in January 1994. The major new features included in this release were the functional programming tools lambda, map, filter and reduce. Van Rossum stated that \\\"Python acquired lambda, reduce(), filter() and map(), courtesy of a Lisp hacker who missed them and submitted working patches\\\".\"}],\"\\n\"]}]\n38:[\"$\",\"p\",null,{\"children\":[\"$\",\"img\",null,{\"src\":\"https://imgs.xkcd.com/comics/lisp_cycles.png\",\"alt\":\"\"}]}]\n39:[\"$\",\"p\",null,{\"children\":[[\"$\",\"a\",null,{\"href\":\"https://github.com/mattbruv/mplisp\",\"target\":\"_blank\",\"className\":\"underline\",\"children\":\"Source code for mplisp\"}],\".\"]}]\n"])</script><script>self.__next_f.push([1,"3a:[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"1\"}]\n3b:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"if\"}]\n3c:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"\u003c\"}]\n3d:[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0\"}]\n3e:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"+\"}]\n3f:[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"1\"}]\n40:[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0\"}]\n41:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"-\"}]\n42:[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"1\"}]\n43:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"if\"}]\n44:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"\u003e\"}]\n45:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"+\"}]\n46:[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"1\"}]\n47:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"define\"}]\n48:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"lambda\"}]\n49:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"xVel\"}]\n4a:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"step\"}]\n4b:[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0\"}]\n4c:[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0\"}]\n4d:[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0\"}]\n4e:[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0\"}]\n4f:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"define\"}]\n50:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"lambda\"}]\n51:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"x\"}]\n52:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"if\"}]\n53:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"\u003c=\"}]\n54:[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"1\"}]\n55:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"+\"}]\n56:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"xVelDist\"}]\n57:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"-\"}]\n58:[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"1\"}]\n59:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"define\"}"])</script><script>self.__next_f.push([1,"]\n5a:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"lambda\"}]\n5b:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"from\"}]\n5c:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"if\"}]\n5d:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"=\"}]\n5e:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"+\"}]\n5f:[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"1\"}]\n60:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"range\"}]\n61:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"+\"}]\n62:[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"1\"}]\n63:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"cons\"}]\n64:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"-\"}]\n65:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"define\"}]\n66:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"range\"}]\n67:[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0\"}]\n68:[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"100\"}]\n69:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"define\"}]\n6a:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"range\"}]\n6b:[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0\"}]\n6c:[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"100\"}]\n6d:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"define\"}]\n6e:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"lambda\"}]\n6f:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"x\"}]\n70:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"\u003e\"}]\n71:[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0\"}]\n72:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"define\"}]\n73:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"filter\"}]\n74:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"lambda\"}]\n75:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"x\"}]\n76:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"inX\"}]\n77:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"xVelDist\"}]\n78:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"define\"}]\n79:[\"$\",\"span\",null,{\"className\":"])</script><script>self.__next_f.push([1,"\"hljs-name\",\"children\":\"lambda\"}]\n7a:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"x\"}]\n7b:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"max\"}]\n7c:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"filter\"}]\n7d:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"map\"}]\n7e:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"lambda\"}]\n7f:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"y\"}]\n80:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"shoot\"}]\n81:[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0\"}]\n82:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"max\"}]\n83:[\"$\",\"span\",null,{\"className\":\"hljs-name\",\"children\":\"map\"}]\n84:[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0\"}]\n"])</script></body></html>